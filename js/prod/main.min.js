// enquire.js v1.5.6 - Awesome Media Queries in JavaScript
// Copyright (c) 2013 Nick Williams - http://wicky.nillia.ms/enquire.js
// License: MIT (http://www.opensource.org/licenses/mit-license.php)


window.enquire = (function(matchMedia) {

    "use strict";

    /**
     * Helper function for iterating over a collection
     *
     * @param collection
     * @param fn
     */
    function each(collection, fn) {
        var i      = 0,
            length = collection.length,
            cont;

        for(i; i < length; i++) {
            cont = fn(collection[i], i);
            if(cont === false) {
                break; //allow early exit
            }
        }
    }

    /**
     * Helper function for determining whether target object is an array
     *
     * @param target the object under test
     * @return {Boolean} true if array, false otherwise
     */
    function isArray(target) {
        return Object.prototype.toString.apply(target) === "[object Array]";
    }

    /**
     * Helper function for determining whether target object is a function
     *
     * @param target the object under test
     * @return {Boolean} true if function, false otherwise
     */
    function isFunction(target) {
        return typeof target === "function";
    }

    /**
     * Delegate to handle a media query being matched and unmatched.
     *
     * @param {object} options
     * @param {function} options.match callback for when the media query is matched
     * @param {function} [options.unmatch] callback for when the media query is unmatched
     * @param {function} [options.setup] one-time callback triggered the first time a query is matched
     * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
     * @constructor
     */
    function QueryHandler(options) {
        this.initialised = false;
        this.options = options;

        if(!options.deferSetup) {
      this.setup();
    }
    }
    QueryHandler.prototype = {

        /**
         * coordinates setup of the handler
         *
         * @function
         */
        setup : function(e) {
            if(this.options.setup){
                this.options.setup(e);
            }
            this.initialised = true;
        },

        /**
         * coordinates setup and triggering of the handler
         *
         * @function
         * @param [e] the browser event which triggered a match
         */
        on : function(e) {
            if(!this.initialised){
                this.setup(e);
            }
            this.options.match(e);
        },

        /**
         * coordinates the unmatch event for the handler
         *
         * @function
         * @param [e] the browser event which triggered a match
         */
        off : function(e) {
            if(this.options.unmatch){
                this.options.unmatch(e);
            }
        },

        /**
         * called when a handler is to be destroyed.
         * delegates to the destroy or unmatch callbacks, depending on availability.
         *
         * @function
         */
        destroy : function() {
            if(this.options.destroy) {
                this.options.destroy();
            }
            else {
                this.off();
            }
        },

        /**
         * determines equality by reference.
         * if object is supplied compare options, if function, compare match callback
         *
         * @function
         * @param {object || function} [target] the target for comparison
         */
        equals : function(target) {
            return this.options === target || this.options.match === target;
        }

    };
/**
 * Represents a single media query, manages it's state and registered handlers for this query
 *
 * @constructor
 * @param {string} query the media query string
 * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
 */
function MediaQuery(query, isUnconditional) {
    this.query = query;
    this.isUnconditional = isUnconditional;
    
    this.handlers = [];
    this.matched = false;
}
MediaQuery.prototype = {

    /**
     * tests whether this media query is currently matching
     *
     * @function
     * @returns {boolean} true if match, false otherwise
     */
    matchMedia : function() {
        return matchMedia(this.query).matches;
    },

    /**
     * add a handler for this query, triggering if already active
     *
     * @function
     * @param {object} handler
     * @param {function} handler.match callback for when query is activated
     * @param {function} [handler.unmatch] callback for when query is deactivated
     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
     * @param {boolean} [turnOn=false] should the handler be turned on if the query is matching?
     */
    addHandler : function(handler, turnOn) {
        var qh = new QueryHandler(handler);
        this.handlers.push(qh);

        turnOn && this.matched && qh.on();
    },

    /**
     * removes the given handler from the collection, and calls it's destroy methods
     *
     * @function
     * @param {object || function} handler the handler to remove
     */
    removeHandler : function(handler) {
        var handlers = this.handlers;
        each(handlers, function(h, i) {
            if(h.equals(handler)) {
                h.destroy();
                return !handlers.splice(i,1); //remove from array and exit each early
            }
        });
    },

    /*
     * assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
     *
     * @function
     */
    assess : function(e) {
        if(this.matchMedia() || this.isUnconditional) {
            this.match(e);
        }
        else {
            this.unmatch(e);
        }
    },

    /**
     * activates a query.
     * callbacks are fired only if the query is currently unmatched
     *
     * @function
     * @param {Event} [e] browser event if triggered as the result of a browser event
     */
    match : function(e) {
        if(this.matched) {
      return; //already on
    }

        each(this.handlers, function(handler) {
            handler.on(e);
        });
        this.matched = true;
    },

    /**
     * deactivates a query.
     * callbacks are fired only if the query is currently matched
     *
     * @function
     * @param {Event} [e] browser event if triggered as the result of a browser event
     */
    unmatch : function(e) {
        if(!this.matched) {
      return; //already off
        }

        each(this.handlers, function(handler){
      handler.off(e);
        });
        this.matched = false;
    }
};
    /**
     * Allows for reigstration of query handlers.
     * Manages the  query handler's state and is responsible for wiring up browser events
     *
     * @constructor
     */
    function MediaQueryDispatch () {
        if(!matchMedia) {
            throw new Error('matchMedia is required');
        }

        var capabilityTest = new MediaQuery('only all');
        this.queries = {};
        this.listening = false;
        this.browserIsIncapable = !capabilityTest.matchMedia();
    }

    MediaQueryDispatch.prototype = {

        /**
         * Registers a handler for the given media query
         *
         * @function
         * @param {string} q the media query
         * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
         * @param {function} options.match fired when query matched
         * @param {function} [options.unmatch] fired when a query is no longer matched
         * @param {function} [options.setup] fired when handler first triggered
         * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
         * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
         */
        register : function(q, options, shouldDegrade) {
            var queries         = this.queries,
                isUnconditional = shouldDegrade && this.browserIsIncapable,
                listening       = this.listening;

            if(!queries.hasOwnProperty(q)) {
                queries[q] = new MediaQuery(q, isUnconditional);

                this.listening && queries[q].assess();
            }

            //normalise to object
            if(isFunction(options)) {
                options = {
                    match : options
                };
            }
            //normalise to array
            if(!isArray(options)) {
                options = [options];
            }
            each(options, function(handler) {
                queries[q].addHandler(handler, listening);
            });

            return this;
        },

        /**
         * unregisters a query and all it's handlers, or a specific handler for a query
         *
         * @function
         * @param {string} q the media query to target
         * @param {object || function} [handler] specific handler to unregister
         */
        unregister : function(q, handler) {
            var queries = this.queries;

            if(!queries.hasOwnProperty(q)) {
                return this;
            }
            
            if(!handler) {
                each(this.queries[q].handlers, function(handler) {
                    handler.destroy();
                });
                delete queries[q];
            }
            else {
                queries[q].removeHandler(handler);
            }

            return this;
        },

        /**
         * Tests all media queries and calls relevant methods depending whether
         * transitioning from unmatched->matched or matched->unmatched
         *
         * @function
         * @param {Event} [e] if fired as a result of a browser event,
         * an event can be supplied to propagate to the various media query handlers
         */
        fire : function(e) {
            var queries = this.queries,
                mediaQuery;

            for(mediaQuery in queries) {
                if(queries.hasOwnProperty(mediaQuery)) {
                    queries[mediaQuery].assess(e);
        }
            }
            return this;
        },

        /**
         * sets up listeners for resize and orientation events
         *
         * @function
         * @param {int} [timeout=500] the time (in milliseconds) after which the queries should be handled
         */
        listen : function(timeout) {
            var self = this;

            timeout = timeout || 500;

            //creates closure for separate timed events
            function wireFire(event) {
                var timer;

                window.addEventListener(event, function(e) {
                    timer && clearTimeout(timer);

                    timer = setTimeout(function() {
                        self.fire(e);
                    }, timeout);
                }, false);
            }

            //prevent multiple event handlers
            if(this.listening) {
                return this;
            }

            // any browser that doesn't implement this
            // will not have media query support
            if(window.addEventListener) {
                wireFire('resize');
                wireFire('orientationChange');
            }

            self.fire();
            this.listening = true;
            
            return this;
        }
    };


    return new MediaQueryDispatch();

}(window.matchMedia));

/* **********************************************
     Begin main.js
********************************************** */

/* @codekit-prepend "lib/enquire.js" */

String.prototype.contains = function(it) { return this.indexOf(it) != -1; };

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
  BADRACKET APP
\* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var s,
badracket = {

  settings: {
    bd: $('body'),
    playBar: $('.controls .position'),
    playSlider: $('#slider'),
    audioPlayer: $('.audio-player')
  },

  init: function() {
    s = this.settings;
    this.docReady();
    this.load();
    this.djaxLoad();
  },

  enquire: function(){
    enquire .register("screen and (max-width : 1024px)", badracket.setupMobile())
      .listen();
  },


  setupMobile: function(){
    return {
      setup: function() {
        badracket.loader.require([
        badracket_theme_path + "js/lib/jquery.tap.js"],
            function() {
                // Callback
                badracket.bindMobileUI();
            });
      },
      deferSetup: true,
      match : function() {
      },
      unmatch : function() {  }
    };
  },

  setup: function(){
    badracket.loader.require([
    badracket_theme_path + "/js/lib/soundmanager2.js",
    badracket_theme_path + "/js/lib/jquery-ui-1.9.2.custom.js",
    badracket_theme_path + "/js/badracket.audio-player.js",
    badracket_theme_path + "/js/lib/jquery.fitvids.js"],
        function() {
            // Callback
            console.log('All Scripts Loaded');
            $('.video').fitVids();
            badracket.soundmanager.smSetup();
            if (badracket.hasCookie('sm_currentURL')) {
              badracket.resumePlayback();
            }
        });
    badracket.beforeUnload();
  },

   loader: {
      require: function (scripts, callback) {
          this.loadCount      = 0;
          this.totalRequired  = scripts.length;
          this.callback       = callback;

          for (var i = 0; i < scripts.length; i++) {
              this.writeScript(scripts[i]);
          }
      },
      loaded: function (evt) {
          this.loadCount++;
   
          if (this.loadCount == this.totalRequired && typeof this.callback == 'function') this.callback.call();
      },
      writeScript: function (src) {
          var self = this;
          var s = document.createElement('script');
          s.type = "text/javascript";
          s.async = true;
          s.src = src;
          s.addEventListener('load', function (e) { self.loaded(e); }, false);
          var head = document.getElementsByTagName('head')[0];
          head.appendChild(s);
        }
      },

  setCookie: function(key,value,days){
    var expires;
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      expires = "; expires="+date.toGMTString();
    } else {
     expires = "";
   }
   document.cookie = key +"="+value+expires+"; path=/";
    },

  getCookie: function(sKey) {
    if (!sKey || !badracket.hasCookie(sKey)) { return null; }
    return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
  },
  removeCookie: function(key) {
    document.cookie = encodeURIComponent(key) + "=deleted; expires=" + new Date(0).toUTCString() + "; path=/";
  },
  hasCookie: function(sKey) {
    return (new RegExp("(?:^|;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
  },

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
    Normalize album data
  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


  objValueToString: function(obj, key) {
    if (obj.hasOwnProperty(key)) {
       obj[key] = obj[key].toString();
    }
    return obj;
  },

  deleteProperty: function (obj, key) {
      if (obj.hasOwnProperty(key)) {
        delete obj[key];
      }
      return obj;
  },

  renameProperty: function (obj, oldName, newName) {
      if (obj.hasOwnProperty(oldName)) {
          obj[newName] = obj[oldName];
          delete obj[oldName];
      }
      return obj;
  },

  count_tracks: function(obj) {
      var trackCount=0;
      for (var prop in obj) {
        if (prop.toString().contains('songTitle')) {
          trackCount++;
        }
      }
      return trackCount;
  },

  // de-enumerate keys of all track objects within album object
  createAblumHierarchy: function(obj) {
    obj.tracks = [];
    var trackCount = badracket.count_tracks(obj);
    for (var i=1; i <= trackCount; i++) {
      var trackTemp = {};
      for (var prop in obj) {
        if (prop.toString().contains(i.toString())) { // if property name containers enumerator
          trackTemp[prop] = obj[prop].toString();
          delete obj[prop];
          }
        }
        obj.tracks.push(trackTemp);
      }
  },

  cleanTrackPropKeys: function(array) {
    trackcount = array.length;
    for (i=0; i<trackcount; i++) {
      for (var prop in array[i]) {
        if (prop.contains('duration')) { badracket.renameProperty(array[i], prop, 'duration'); }
        else if (prop.contains('songTitle')) { badracket.renameProperty(array[i], prop, 'songTitle'); }
        else if (prop.contains('TrackNumber')) { badracket.renameProperty(array[i], prop, 'trackNumber'); }
        else if (prop.contains('songUrl')) { badracket.renameProperty(array[i], prop, 'songUrl'); }
        else if (prop.contains('checkbox')) { badracket.renameProperty(array[i], prop, 'isSampleTrack'); }
      }
    }
  },

  cleanAlbumProperties: function(albumObject) {

    // Delete WP properties from album object
    badracket.deleteProperty(albumObject, '_edit_last');
    badracket.deleteProperty(albumObject, '_edit_lock');

    // Clean Album property key names
    // oldName, newName
    badracket.renameProperty(albumObject, '_br_artist','artist');
    badracket.renameProperty(albumObject, '_br_zip_file','zipFile');
    badracket.renameProperty(albumObject, '_br_cover_url','cover');
    badracket.renameProperty(albumObject, '_br_release_date','releaseDate');
    badracket.renameProperty(albumObject, '_br_buy_url','buyUrl');
    badracket.renameProperty(albumObject, '_br_recording_studio','recordingStudio');

    // Set album-level property values to strings instead of arrays
    badracket.objValueToString(albumObject, 'artist');
    badracket.objValueToString(albumObject, 'zipFile');
    badracket.objValueToString(albumObject, 'cover');
    badracket.objValueToString(albumObject, 'releaseDate');
    badracket.objValueToString(albumObject, 'buyUrl');
    badracket.objValueToString(albumObject, 'recordingStudio');
  },

  initAlbumNormalization: function(objArray) {
    for (i=0; i<objArray.length; i++) {
      // console.log(objArray[i]);
      badracket.createAblumHierarchy(objArray[i]);
      badracket.cleanAlbumProperties(objArray[i]);
      badracket.cleanTrackPropKeys(objArray[i].tracks);
    }
    console.log(objArray);
  },


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
    Get album data via ajax
  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

  doAjaxRequest: function(){
       // here is where the request will happen
       console.log('jquery ajax request ran');
       jQuery.ajax({
            url: 'http://localhost:8888/sites/brv5/wp-br/wp-admin/admin-ajax.php',
            data:{
                 'action':'do_ajax',
                 'fn':'get_latest_posts',
                 'post_type': 'album',
                 'count':99
                 },
            dataType: 'JSON',
            success:function(data){
                   badracket.albums = data;
                   badracket.initAlbumNormalization(badracket.albums);

                 },
            error: function(errorThrown){
                 alert('error');
                 console.log(errorThrown);
            }
       });

  },

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
    Document.ready()
  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

  docReady: function(){
    $(document).ready(function(){
      badracket.enquire();

      console.log('document ready fires');

      badracket.doAjaxRequest();





    });
  },

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
    Window.load()
  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

  load: function(){
    $(window).load(function(){
      badracket.setup();

      badracket.lazyLoadImg();
    });
  },

  djaxLoad: function(){

    // when djax element loads, remove loadin class & mimic doc ready stuff
    $(window).bind('djaxLoad', function(e, data) {
      badracket.lazyLoadImg();
      badracket.soundmanager.djaxInit();
      $('.main-content').removeClass('loading');
    });

    // when djax link clicked, add loading class
    $(window).bind('djaxClick', function(e, data) {
      $('.main-content').addClass('loading');
    });
  },

  lazyLoadImg: function(){
    $('.lazyload').each(function() {
     console.log('lazyload ran');
     var lazy = $(this);
     var src = lazy.attr('data-src');
     $('<img>').attr('src', src).load(function(){
          lazy.css('background-image', 'url("'+src+'")');
          if (lazy.hasClass('fade')) {
            lazy.parent().addClass('loaded');
          } else if (lazy.hasClass('fade-this')) {
            lazy.addClass('loaded');
          }
        });
    });
  },



  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
    Extend javascript prototypes
  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */




  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *\
   beforeUnload()
  \* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

  beforeUnload: function() {
    window.onbeforeunload = function() {
      // if (badracket.soundmanager.getCurrentSong()) {
      //   var mySound = badracket.soundmanager.getCurrentSong();
      //   if (mySound  && mySound.position) { // sound is playing
      //     badracket.setCookie('sm_lastPosition', mySound.position);
      //     badracket.setCookie('sm_duration', mySound.duration);
      //     badracket.setCookie('sm_paused', mySound.paused);
      //     badracket.setCookie('sm_stopped', mySound.playState);
      //     badracket.setCookie('sm_currentURL', mySound.url);
      //     badracket.setCookie('songTitle', $('.song').text());
      //     badracket.setCookie('artistName', $('.artist').text());
        // }
      // } else {
        // no sound, or not playing etc. Remove play state cookies.
        badracket.removeCookie('sm_lastPosition');
        badracket.removeCookie('sm_paused');
        badracket.setCookie('sm_stopped');
        badracket.removeCookie('sm_currentURL');
        badracket.removeCookie('sm_duration');
        badracket.removeCookie('songTitle');
        badracket.removeCookie('artistName');
      // }
    };
  }, // end beforeUnload

  bindMobileUI: function(){
    $('.menu').on('tap',function(){
      badracket.updatePageState('nav-state');
    });

    $('nav[role="navigation"] a').on('tap',function(){
     s.bd.attr('data-state', 'default-state');
    });

    $('.info').on('tap',function(){
      badracket.updatePageState('info-state');
    });

    $(document).bind("pageinit", function(event) {
      $.event.special.swipe.verticalDistanceThreshold = 40;
      $.event.special.swipe.horizontalDistanceThreshold = 160;
      $.event.special.swipe.durationThreshold = 300;
      $('body').bind('swipeleft', function(){ badracket.updatePageState('info-state'); });
      $('body').bind('swiperight', function(){ badracket.updatePageState('nav-state'); });
    });
  },

  updatePageState: function(pageState){
    if (s.bd.attr('data-state') === 'default-state') {
      s.bd.attr('data-state', pageState);
    } else {
      s.bd.attr('data-state', 'default-state');
    }
  },



};

badracket.init();






